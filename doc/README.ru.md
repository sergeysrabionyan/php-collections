# PHP Коллекции
Библиотека для удобной работы с массивами данных различных структур с использованием функционального подхода. В основе лежат структуры данных, такие как: Список, Карта, Множество, Стек, Очередь. 

Для обхода и преобразования коллекций используется stream api (Stream), который обеспечивает более функциональный подход.

Читать на других языках: [English](../README.md)

## Системные требования
[```PHP 7.2+```](https://www.php.net/downloads)

## Установка
Установить и использовать библиотеку в собственном проекте можно использовав  менеджер зависимостей [Composer](https://getcomposer.org/)
```bash
composer require worksolutions/php-collections
``` 

## Пример использования
```php

use WS\Utils\Collections\CollectionFactory;
use WS\Utils\Collections\Functions\Predicates;

// Отобрать элементы по фильтру
CollectionFactory::from([1, 2, 3])
    ->stream()
    ->filter(Predicates::moreThan(1))
    ->getCollection(); // Collection [2, 3]

// Распечатать все файлы в директории
CollectionFactory::fromIterable(new DirectoryIterator(__DIR__))
    ->stream()
    ->each(static function (SplFileInfo $fileInfo) {
        echo $fileInfo->getFilename() . "\n";
    });

```

## Основные концепции

В основе использования библиотеки лежит последовательный подход обработки и преобразования данных. Создание некого конвейера преобразования, где можно последовательно выполнять некие шаги. Каждый шаг отвечает только за свой небольшой кусочек работы. В этом случае шаги можно переиспользовать так как они являются более наглядными.

Фундаментально библиотека состоит из нескольких частей, это: 

- [Структуры данных.](#Структуры-данных) Каждая имеет свою особенность, выраженную при помощи интерфейса и описания к нему, и реализацию. При этом реализации поведения структур данных могут быть разные.
- [Фабрика создания коллекции.](#Фабрика-создания-коллекции) Имеет множество статических методов для удобного создания коллекций.
- [Потоки обхода коллекций.](#Потоки-обхода-коллекций) Предназначен для обхода и преобразования коллекций, при этом каждое преобразование создает новый экземпляр коллекции.
- [Набор функций обхода и преобразования.](#Набор-функций-обхода-и-преобразования) Состоит из заранее подготовленных конструкторов функций для удобного использования в момент обхода. Можно создать использовать собственные функции более специфичные для вашей предметной области.

## Структуры данных

В основе библиотеки лежат самые популярные структуры данных которые являются самодостаточными для использования без каких-либо посторонних библиотек и классов. Все остальные части библиотеки основываются на эти структуры, в частности на интерфейс `Collection`. Все структуры данных коллекций содержат множество элементов с которыми можно проводить основные процедуры, такие как: обход, преобразование, агрегирования и т.д.

- [Коллекция (Collection)](#коллекция-collection)
- [Список (ListSequence)](#список-listsequence)
- [Множество (Set)](#множество-set)
- [Очередь (Queue)](#очередь-queue)
- [Стек (Stack)](#стек-stack)
- [Карта (Map)](#карта-map)

### Коллекция (Collection) 
[[↑ К разделу]](#Структуры-данных)

Основной базовый интерфейс коллекций. Все структуры данных кроме `карт (Map)` реализуют этот интерфейс, весь дополнительный функционал (Фабрики, Потоки обхода) используют данный интерфейс. Для поддержания универсальности в своих приложениях рекомендуется использовать именно интерфейс  `Collection`, но только в том случае если это не противоречит назначению использования структуры. 

Коллекции доступны для обхода при помощи цикла [```foreach```](#обход-коллекции-при-помощи-цикла-foreach).

#### Методы интерфейса

- [*add* – Добавление элемента в коллекцию](#добавление-элемента-в-коллекцию)
- [*addAll* – Добавление множества элементов в коллекцию](#Добавление-множества-элементов-в-коллекцию)
- [*merge* – Слияние коллекций](#Слияние-коллекций)
- [*clear* – Удаление всех элементов коллекции](#Удаление-всех-элементов-коллекции)
- [*remove* – Удаление элемента коллекции](#Удаление-элемента-коллекции)
- [*contains* – Проверка на существование элемента в коллекции](#Проверка-на-существование-элемента-в-коллекции)
- [*equals* – Сравнение двух коллекций на эквивалентность](#Сравнение-двух-коллекций-на-эквивалентность)
- [*size* – Получение количества элементов в коллекции](#Получение-количества-элементов-в-коллекции)
- [*isEmpty* – Проверка коллекции на пустоту](#Проверка-коллекции-на-пустоту)
- [*toArray* – Получение элементов коллекции в виде массива](#Получение-элементов-коллекции-в-виде-массива)
- [*copy* – Получение копии коллекции](#Получение-копии-коллекции)
- [*stream* – Получение потока обхода коллекции (Stream)](#Получение-потока-обхода-коллекции-Stream)
- [Обход коллекции при помощи цикла *foreach*](#обход-коллекции-при-помощи-цикла-foreach)

#### Добавление элемента в коллекцию

[[↑ К разделу]](#коллекция-collection)
```
add($element: mixed): bool;
```
Добавляет элемент в конец коллекции. Возвращает `true` в случае успешного ответа или `false` при неудаче.
```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2]); // [1, 2]
$collection->add(10); // [1, 2] -> [1, 2, 10];

```
#### Добавление множества элементов в коллекцию
[[↑ К разделу]](#коллекция-collection)
```
addAll($elements: iterable): bool;
```
Добавляет множества элементов в конец коллекции. Возвращает `true` в случае успешного ответа или `false` при неудаче.
```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2]); // [1, 2]
$collection->add([10, 11, 12]); // true
$collection->toArray(); // [1, 2] -> [1, 2, 10, 11, 12];

```
#### Слияние коллекций
[[↑ К разделу]](#коллекция-collection)
```
merge($collection: Collection): bool;
```
Метод объединяет текущую коллекцию с переданной. Возвращает `true` в случае успешного ответа или `false` при неудаче.
```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2]); // [1, 2]
$mergingCollection = CollectionFactory::from([11, 12]); // [11, 12]
$collection->merge($mergingCollection); // true
$collection->toArray(); // [1, 2, 10, 11, 12];

```
#### Удаление всех элементов коллекции
[[↑ К разделу]](#коллекция-collection)
```
clear(): void;
```
Метод удаляет все элементы коллекции.
```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2]); // [1, 2]
$collection->clear(); // null
$collection->toArray(); // [];

```
#### Удаление элемента коллекции
[[↑ К разделу]](#коллекция-collection)
```
remove($element: mixed): bool;
```

Удаление конкретного элемента в коллекции. Метод возвращает признак удаления элемента. Если элемента не существовало, вернется `false`.

```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$collection->remove(2); // true
$collection->remove(4); // false
$collection->toArray(); // [1, 3];

```
#### Проверка на существование элемента в коллекции
[[↑ К разделу]](#коллекция-collection)
```
contains($element: mixed): bool;
```

Проверка наличия конкретного элемента в коллекции. Если элемента не существует, вернется `false`.

```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$collection->contains(2); // true
$collection->contains(4); // false

```
#### Сравнение двух коллекций на эквивалентность
[[↑ К разделу]](#коллекция-collection)
```
equals($collection: Collection): bool;
```

Метод проверяет, что переданная коллекция эквивалентна текущей, это означает что все элементы одной коллекции содержатся в другой коллекции и количество элементов равно. В случае неравенства коллекций, вернется `false`.

```php

use WS\Utils\Collections\HashSet;

$set1 = new HashSet([1, 2, 3]);
$set2 = new HashSet([3, 2, 1]);
$set3 = new HashSet([3, 2]);

$set1->equals($set2); // true
$set2->equals($set1); // true
$set1->equals($set3); // false

```
#### Получение количества элементов в коллекции
[[↑ К разделу]](#коллекция-collection)
```
size(): int;
```

Метод возвращает число элементов в коллекции. Если коллекция пустая - 0.

```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$collection->size(); // 3

$emptyCollection = CollectionFactory::from([]);
$emptyCollection->size(); // false

```
#### Проверка коллекции на пустоту
[[↑ К разделу]](#коллекция-collection)
```
isEmpty(): bool;
```
Метод возвращает признак пустой коллекции. Если в коллекции существуют элементы, вернется `false`.
```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$collection->isEmpty(); // false

$emptyCollection = CollectionFactory::from([]);
$emptyCollection->isEmpty(); // true

```
#### Получение элементов коллекции в виде массива
[[↑ К разделу]](#коллекция-collection)
```
toArray(): array;
```

Метод индексированный массив состоящий из элементов коллекции, порядок следования элементов зависит от внутреннего представления.

```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$collection->toArray(); // [1, 2, 3]

$emptyCollection = CollectionFactory::from([]);
$emptyCollection->toArray(); // []

```
#### Получение копии коллекции
[[↑ К разделу]](#коллекция-collection)
```
copy(): Collection;
```
Метод возвращает точную копию коллекции. Коллекции - мутабельны. Это означает, что применение методов модификации изменяет коллекцию, для гарантии неизменности коллекции рекомендуется применять метод копирования.
```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$copyOfCollection = $collection->copy(); // Collection

$copyOfCollection === $collection; // false

```
#### Получение потока обхода коллекции (Stream)
[[↑ К разделу]](#коллекция-collection)
```
stream(): Stream;
```

Метод объект который реализует интерфейс обхода коллекции (Stream). Поток обхода коллекции является очень мощным инструментом и в большинстве случаев при разработке приходится иметь дело именно с ним. [Подробнее...](#Поток обхода коллекции)

```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]
$collection
    ->stream()
    ->each(static function (int $el) {var_export($el);}); // 1 2 3

```
#### Обход коллекции при помощи цикла *foreach*
[[↑ К разделу]](#коллекция-collection)

Коллекции доступны для обхода при в цикле *foreach*. Порядок перебора коллекции зависит от внутренней реализации конкретного класса.

```php

use WS\Utils\Collections\CollectionFactory;

$collection = CollectionFactory::from([1, 2, 3]); // [1, 2, 3]

foreach($collection as $item) {
    var_export($item);
}

```
### Список (ListSequence) 
[[↑ К разделу]](#Структуры-данных)

Списком является структура данных в которой строго определен порядок элементов. Списки с одинаковым набором элементов и разной их последовательностью не равны. Интерфейс ListSequence расширяет интерфейс Collection. 

Интерфейс списка (ListSequence) расширяет интерфейсы: [```Collection```](#коллекция-collection)

Интерфейс списка (ListSequence) реализуют классы: ```ArrayList, ImmutableList```

#### Методы интерфейса

- [*get* – Получение элемента по порядковому индексу](#Получение-элемента-по-порядковому-индексу)
- [*set* – Замена элемента списка](#Замена-элемента-списка)
- [*indexOf* – Получение порядкового индекса элемента](#Получение-порядкового-индекса-элемента)
- [*lastIndexOf* – Получение порядкового индекса последнего подходящего элемента](#Получение-порядкового-индекса-последнего-подходящего-элемента)
- [*removeAt* – Удаление элемента по индексу](#Удаление-элемента-по-индексу)

#### Получение элемента по порядковому индексу
[[↑ К разделу]](#список-listsequence)
```
get($index: int): mixed;
```
Метод возвращает элемент по индексу. Если по индексу элемента не существует, вернет null. Первый элемент списка имеет индекс 0.
```php

use WS\Utils\Collections\ArrayList;

$list = ArrayList::of(1, 2);

$list->get(0); // 1
$list->get(1); // 2
$list->get(2); // null

```
#### Замена элемента списка
[[↑ К разделу]](#список-listsequence)
```
set($element: mixed, $index: int): mixed;
```
Метод заменяет элемент по индексу. Возвращает значение элемента который был заменен текущим методом. Если происходит попытка заменить не существующий элемент, OutOfRangeException будет выброшен.
```php

use WS\Utils\Collections\ArrayList;

$list = ArrayList::of(1, 2);

$list->set(3, 0); // 1
$list->set(4, 1); // 2
$list->set(4, 2); // OutOfRangeException

```
#### Получение порядкового индекса элемента
[[↑ К разделу]](#список-listsequence)
```
indexOf($element: mixed): ?int;
```
Метод возвращает первый индекс найденного элемента. В случае отсутствия значения в списке, вернется `null`.
```php

use WS\Utils\Collections\ArrayList;

$list = ArrayList::of(1, 2, 1, 3);

$list->indexOf(1); // 0
$list->indexOf(2); // 1
$list->indexOf(4); // null

```
#### Получение порядкового индекса последнего подходящего элемента
[[↑ К разделу]](#список-listsequence)
```
lastIndexOf($element: mixed): ?int;
```
Метод возвращает последний индекс найденного элемента. В случае отсутствия значения в списке, вернется `null`.
```php

use WS\Utils\Collections\ArrayList;

$list = ArrayList::of(1, 2, 1, 3);

$list->indexOf(1); // 2
$list->indexOf(2); // 1
$list->indexOf(3); // null

```
#### Удаление элемента по индексу
[[↑ К разделу]](#список-listsequence)
```
removeAt(int $index): mixed;
```
Метод удаляет элемент по индексу, элементы находящиеся после удаленного индекса перемещаются ближе к началу на одну позицию. Возвращает значение удаленного элемента. В случае отсутствия элемента по индексу вернется `null`.
```php

use WS\Utils\Collections\ArrayList;

$list = ArrayList::of(1, 2, 1, 3);

$list->removeAt(1); // 2
$list->toArray(); // [1, 1, 3]

```
### Множество (Set)

[[↑ К разделу]](#Структуры-данных)

Множество содержит только уникальные элементы, порядок следования элементов может быть любым. То есть добавление элемента методом `add` не гарантирует его последнее место среди остальных элементов при итерировании и в случае наличия элемента с таким же значением, последний не добавится в множество. 

Уникальность определяется значением, а для объектов либо уникальностью конкретного объекта, либо в случае если объект реализует интерфейс ``HashCodeAware`` уникальностью результата вызова метода ``getHashCode(): string;``.

Интерфейс множества (Set) расширяет интерфейсы: [```Collection```](#коллекция-collection)

Интерфейс множества (Set) реализуют классы: ```HashSet```


### Очередь (Queue)
[[↑ К разделу]](#Структуры-данных)

Такая структура данных как очередь удобна для последовательной обработки данных в порядке поступления. Она обладает удобными методами добавления и потребления элементов. Первый элемент, который попал в очередь - первым ее и покинет.

Интерфейс очереди (Queue) расширяет интерфейсы: [```Collection```](#коллекция-collection)

Интерфейс очереди (Queue) реализуют классы: ```ArrayQueue```

#### Методы интерфейса

- [*offer* – Вставка элемента в очередь](#вставка-элемента-в-очередь)
- [*poll* – Получение элемента и удаление его из очереди](#получение-элемента-и-удаление-его-из-очереди)
- [*peek* – Получение элемента без удаления его из очереди](#получение-элемента-без-удаления-его-из-очереди)

#### Вставка элемента в очередь
[[↑ К разделу]](#очередь-queue)
```
offer($element): bool;
```
Метод добавляет элемент в конец очереди. Возвращает ``false`` если элемент не был добавлен, возможно в случае ограниченной очереди.
```php

use WS\Utils\Collections\ArrayQueue;

$queue = ArrayQueue::of(1, 2);

$queue->offer(3); // [1, 2, 3]
$queue->peek(); // 3

```
#### Получение элемента и удаление его из очереди
[[↑ К разделу]](#очередь-queue)
```
poll(): mixed;
```
Метод возвращает элемент и удаляет его из начала очереди. В случае отсутствия элементов в очереди будет выброшено исключение `RuntimeException`.
```php

use WS\Utils\Collections\ArrayQueue;

$queue = ArrayQueue::of(1, 2);

$queue->peek(); // 2
$queue->poll(); // [1]
$queue->peek(); // 1

```
#### Получение элемента без удаления его из очереди
[[↑ К разделу]](#очередь-queue)
```
poll(): mixed;
```
Метод возвращает элемент. Очередь при этом не изменяется, элемент остается на своем месте. В случае отсутствия элементов в очереди будет выброшено исключение `RuntimeException`.
```php

use WS\Utils\Collections\ArrayQueue;

$queue = ArrayQueue::of(1, 2, 3);

$queue->peek(); // 2
$queue->size(); // 3

```

### Стек (Stack)
[[↑ К разделу]](#Структуры-данных)

Стек является структурой данных логика работы которой противоположна логике работы очереди. Первый элемент попавшей в стек будет первым и извлечен из него.

Интерфейс стека (Stack) расширяет интерфейсы: [```Collection```](#коллекция-collection)

Интерфейс стека (Stack) реализуют классы: ```ArrayStack```

#### Методы интерфейса

- [*push* – Добавление элемента](#добавление-элемента)
- [*pop* – Получение последнего добавленного элемента](#получение-последнего-добавленного-элемента)
- [*peek* – Получение последнего добавленного элемента без модификации стека](#получение-последнего-добавленного-элемента-без-модификации-стека)

#### Добавление элемента
[[↑ К разделу]](#стек-stack)
```
push($element: mixed): bool;
```
Метод добавляет элемент на вершину стека. Возвращает ``false`` если элемент не был добавлен, возможно в случае ограничений.
```php

use WS\Utils\Collections\ArrayStack;

$queue = ArrayStack::of(1, 2);

$queue->push(3); // [1, 2, 3]
$queue->peek(); // 3

```
#### Получение последнего добавленного элемента
[[↑ К разделу]](#стек-stack)
```
pop(): mixed;
```
Метод возвращает элемент с вершины стека. На вершину стека остается элемент добавленный перед полученным. В случае отсутствия элементов в стеке будет выброшено исключение `RuntimeException`.
```php

use WS\Utils\Collections\ArrayStack;

$queue = ArrayStack::of(1, 2, 3); // [1, 2, 3]

$queue->pop(); // 3
$queue->pop(); // 2
$queue->push(4); // [1, 4]
$queue->pop(); // 4
$queue->peek(); // 1

```
#### Получение последнего добавленного элемента без модификации стека
[[↑ К разделу]](#стек-stack)
```
peek(): mixed;
```
Метод возвращает элемент который расположен на вершине стека. В случае отсутствия элементов в стеке будет выброшено исключение `RuntimeException`.
```php

use WS\Utils\Collections\ArrayStack;

$queue = ArrayStack::of(1, 2, 3); // [1, 2, 3]

$queue->pop(); // 3
$queue->peek(); // 3
$queue->peek(); // 3

$queue->pop(); // 2
$queue->pop(); // 1
$queue->peek(); // RuntimeException

```
### Карта (Map)
[[↑ К разделу]](#Структуры-данных)

Карта представляет отображение или иначе говоря словарь, где каждый элемент представляет пару "ключ-значение". Ключи карты уникальны по значению, если это объекты, то уникальность достигается либо уникальностью ссылки на объект, либо в случае если объект реализует интерфейс ``HashCodeAware`` уникальностью результата вызова метода ``getHashCode(): string;``.

Интерфейс карты (Map) расширяет интерфейсы: ```IteratorAggregate```

Интерфейс карты (Map) реализуют классы: ```HashMap```

#### Методы интерфейса

- [*put* – Добавление пары *ключ/значение*](#добавление-пары-ключзначение)
- [*get* – Получение значения пары по ключу](#получение-значения-пары-по-ключу)
- [*keys* – Получение коллекции ключей карты](#получение-коллекции-ключей-карты)
- [*values* – Получение коллекции значений карты](#получение-коллекции-значений-карты)
- [*remove* – Удаление пары по ключу](#удаление-пары-по-ключу)
- [*containsKey* – Признак наличия пары по ключу](#признак-наличия-пары-по-ключу)
- [*containsValue* – Признак наличия пары по значению](#признак-наличия-пары-по-значению)
- [*size* – Количество пар в карте](#количество-пар-в-карте)

#### Добавление пары *ключ/значение*
[[↑ К разделу]](#карта-map)
```
put($key: mixed, $value: mixed): bool;
```
Метод добавляет пару ключ/значение в объект структуры. Возвращает ``false`` если элемент не был добавлен, возможно в случае ограничений. Как ключом так и значением могут быть данные скалярных типов, массивы и объекты.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

foreach ($map as $k => $v) {
    var_dump($k); // one | two
    var_dump($v); // 1   | 2
}

```
#### Получение значения пары по ключу
[[↑ К разделу]](#карта-map)
```
get($key): mixed;
```
Метод возвращает значение пары по ключу ``key``. В случае, если значения нет вернется ``null``.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

$map->get('one'); // 1
$map->get('three'); // null

```
#### Получение коллекции ключей карты
[[↑ К разделу]](#карта-map)
```
keys(): Collection<mixed>;
```
Метод возвращает коллекцию состоящую из всех ключей карты.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

foreach ($map->keys() as $k) {
    var_dump($k); // one | two
}

```
#### Получение коллекции значений карты
[[↑ К разделу]](#карта-map)
```
values(): Collection<mixed>;
```
Метод возвращает коллекцию состоящую из всех значений пар карты.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

foreach ($map->keys() as $v) {
    var_dump($v); // 1 | 2
}

```
#### Удаление пары по ключу
[[↑ К разделу]](#карта-map)
```
remove($key: mixed): bool;
```
Метод удаляет пару из карты по ключу ``key``.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

$map->remove('one');
foreach ($map->keys() as $v) {
    var_dump($v); // 2
}

```
#### Признак наличия пары по ключу
[[↑ К разделу]](#карта-map)
```
containsKey($key: mixed): bool;
```
Метод возвращает признак наличия пары с ключом ``key``.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

$map->containsKey('one'); // true

```
#### Признак наличия пары по значению
[[↑ К разделу]](#карта-map)
```
containsValue($value: mixed): bool;
```
Метод возвращает признак наличия пары со значением ``value``.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

$map->containsValue(1); // true
$map->containsValue(3); // false

```
#### Количество пар в карте
[[↑ К разделу]](#карта-map)
```
size(): int;
```
Метод возвращает количество пар.

```php

use WS\Utils\Collections\HashMap;

$map = new HashMap();
$map->put('one', 1);
$map->put('two', 2);

$map->size(); // 2

$emptyMap = new HashMap();
$map->size(); // 0

```

## Фабрика создания коллекции

## Потоки обхода коллекций

## Набор функций обхода и преобразования
